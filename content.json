{"pages":[{"title":"Sunanda Bose (a.k.a. Neel Basu)","text":"I am Sunanda Bose, Senior Research Fellow at Department of Computer Science and Engineering at Jadavpur University. Area of my research is Resource Management in Sensor Cloud Infrastructure. My area of work spans but not limited to System Design, Dustributed Architecture, Optimization, Mathematical Modeling, Metaheuristics, Computational Geometry, Spatio Temporal Analysis. Since 2014 I have been working on the project Remote Health: A Framework for Healthcare Services using Mobile and Sensor-Cloud Technologies. Objective of this project was to deliver healthcare to rural areas of West Bengal, India, via Information and Communications Technology (ICT). Health Kiosks has been set up in Barhra village of Birbhum district and Bali island in sundarbans during the tenure of this project. These kiosks has been operated with the health workers working at the village and the doctors working at city remotely.I have previously worked at School of Cultural Texts and Records, Jadavpur University for developing a Text Collation Engine under project Bichitra. I am also involved in developing and contributing to Open Source Softwares in Github and Gitlab. Before joining Jadavpur University I used to work as a software developer in different companies. My programming skills include but not limited to C++, Network Programming, Boost, Qt, Mathematica, Javascript, python, PHP. Following are some of my recent publications. See All Publications Legends: Book Chapter Journal Conference Highlighted Publications SenSchedule: Scheduling Heterogeneous Periodic Sensing Resources with Non Uniform Performance in IoTSunanda Bose, Nandini MukherjeeIEEE Transactions on Services ComputingIEEE 2020 SensIaaS: A sensor-cloud infrastructure with sensor virtualizationSunanda Bose, Nandini Mukherjee2016 IEEE 3rd International Conference on Cyber Security and Cloud Computing (CSCloud)Beijing, China, IEEE 2016 Around the world in 60 days: an exploratory study of impact of COVID-19 on online global news sentimentAmartya Chakraborty, Sunanda BoseJournal of Computational Social ScienceSpringer 2020 LEPaNTU: Long Polling Based Energy Efficient Passive NAT Traversal through UDPSunanda Bose, Akash Chowdhury, Nandini Mukherjee2019 7th International Conference on Future Internet of Things and Cloud (FiCloud)Istanbul, Turkey, IEEE 2019 See All Publications","link":"/about/index.html"},{"title":"Publications","text":"Legends: Book Chapter Journal Conference Highlighted Publications SensIaaS: A sensor-cloud infrastructure with sensor virtualizationSunanda Bose, Nandini Mukherjee2016 IEEE 3rd International Conference on Cyber Security and Cloud Computing (CSCloud)Beijing, China, IEEE 2016 SenSchedule: Scheduling Heterogeneous Periodic Sensing Resources with Non Uniform Performance in IoTSunanda Bose, Nandini MukherjeeIEEE Transactions on Services ComputingIEEE 2020 Around the world in 60 days: an exploratory study of impact of COVID-19 on online global news sentimentAmartya Chakraborty, Sunanda BoseJournal of Computational Social ScienceSpringer 2020 LEPaNTU: Long Polling Based Energy Efficient Passive NAT Traversal through UDPSunanda Bose, Akash Chowdhury, Nandini Mukherjee2019 7th International Conference on Future Internet of Things and Cloud (FiCloud)Istanbul, Turkey, IEEE 2019 PrIOR: A prime number based I/O redirection algorithm for sensor-cloud infrastructureSunanda Bose, Nandini Mukherjee2016 International Conference on High Performance Computing &amp; Simulation (HPCS)Innsbruck, Austria, IEEE 2016 All Publications A Framework for Delivering IoT Services with Virtual Sensors: Case Study Remote Healthcare DeliveryNandini Mukherjee, Sunanda Bose, Himadri Sekhar RayInteroperability in IoT for Smart SystemsCRC Press 2020 Around the world in 60 days: an exploratory study of impact of COVID-19 on online global news sentimentAmartya Chakraborty, Sunanda BoseJournal of Computational Social ScienceSpringer 2020 SenSchedule: Scheduling Heterogeneous Periodic Sensing Resources with Non Uniform Performance in IoTSunanda Bose, Nandini MukherjeeIEEE Transactions on Services ComputingIEEE 2020 A Framework for Heterogeneous Resource Allocation in Sensor-Cloud EnvironmentSunanda Bose, Debangana Sarkar, Nandini MukherjeeWireless Personal Communications vol. 108 no. 1Springer US 2019 LEPaNTU: Long Polling Based Energy Efficient Passive NAT Traversal through UDPSunanda Bose, Akash Chowdhury, Nandini Mukherjee2019 7th International Conference on Future Internet of Things and Cloud (FiCloud)Istanbul, Turkey, IEEE 2019 A Load Balancing Approach to Resource Provisioning in Cloud Infrastructure with a Grouping Genetic AlgorithmKaustabha Ray, Sunanda Bose, Nandini Mukherjee2018 International Conference on Current Trends towards Converging Technologies (ICCTCT)Coimbatore, India, IEEE 2018 Impact of Mobility on Community Sensing with Environment SensorsAtanu Mandal, Sunanda Bose, Nandini Mukherjee2017 13th International Conference on Signal-Image Technology &amp; Internet-Based Systems (SITIS)Jaipur, India, IEEE 2017 PrIOR: A prime number based I/O redirection algorithm for sensor-cloud infrastructureSunanda Bose, Nandini Mukherjee2016 International Conference on High Performance Computing &amp; Simulation (HPCS)Innsbruck, Austria, IEEE 2016 Virtual Sensors in Remote Healthcare Delivery: Some Case Studies.Nandini Mukherjee, Suman Sankar Bhunia, Sunanda BoseProceedings of the 9th International Joint Conference on Biomedical Engineering Systems and Technologies - Volume 5Rome, Italy, HEALTHINF 2016 SensIaaS: A sensor-cloud infrastructure with sensor virtualizationSunanda Bose, Nandini Mukherjee2016 IEEE 3rd International Conference on Cyber Security and Cloud Computing (CSCloud)Beijing, China, IEEE 2016 Environment monitoring in smart cities using virtual sensorsSunanda Bose, Nandini Mukherjee, Sujoy Mistry2016 IEEE 4th International Conference on Future Internet of Things and Cloud (FiCloud)Vienna, Austria, IEEE 2016 Towards a sensor-cloud infrastructure with sensor virtualizationSunanda Bose, Atrayee Gupta, Sriyanjana Adhikary, Nandini MukherjeeProceedings of the Second Workshop on Mobile Sensing, Computing and CommunicationHangzhou, China, ACM 2015 Collation: Prabhed and Its PredecessorsSukanta Chaudhuri, Spandana Bhowmik, Sunanda BoseBichitra: The Making of an Online Tagore VariorumSpringer 2015","link":"/publications/index.html"}],"posts":[{"title":"Listing Terms and Acronyms in Text or LaTeX using bash","text":"I often need to check for inconsistent capitalization in my tex files. So listing all the consecutive capitalized words and characters helps me to decide which one is intentional capitalization and which one is not. The following bash script has two functions can lists all terms (Capitalized Phrase) and acronyms used throughout the input file. 12345678910$ terms filename.tex 19 Cloud Station 9 Sensor Gateway 7 Sensor Cloud Infrastructure ...$ acronyms filename.tex 34 VM 13 IaaS 13 CPU ... To reuse save the code shown at the end as $HOME/shortcuts.sh then issue command source $HOME/shortcuts.sh. use terms and acronyms functions as shown below. And here is the shortcuts.sh. 123456789101112#!/bin/bash# source shortcuts.sh# terms filename.tex# acronyms filename.texterms(){ grep -o -P &quot;(?:[A-Z][a-z]+)\\s+(?:\\s*[A-Z][a-zA-Z]+)+&quot; $1 | sort | uniq -c | sort -nr}acronyms(){ grep -o -P &quot;\\b(?:[A-Z][a-z]*){2,}\\b&quot; $1 | sort | uniq -c | sort -nr}","link":"/2020/12/26/latex-shortcuts-acronyms-terms/"},{"title":"Mathematica++ a C++ library that speaks Mathematica","text":"12345678symbol x(&quot;x&quot;);value res;std::string method = &quot;Newton&quot;;shell &lt;&lt; Values(FindRoot(ArcTan(1000 * Cos(x)), List(x, 1, 2), Rule(&quot;Method&quot;) = method));shell &gt;&gt; res;std::vector&lt;double&gt; results = cast&lt;std::vector&lt;double&gt;&gt;(res);std::cout &lt;&lt; results[0] &lt;&lt; std::endl; // Prints 10.9956 A C++ Library that talks MathematicaDot product and Determinant calculation in Mathematica Language 12345mata = Table[Mod[i + j, 2], {i, 1, 2}, {j, 1, 2}];matb = Table[Mod[i + j, 3], {i, 1, 2}, {j, 1, 2}];matc = Dot[mata, matb];matd = Det[matc]; Equivalent C++ code with Mathematica++ 1234567891011mathematica::m mata = Table(Mod(i + j, 2), List(i, 1, 2), List(j, 1, 2));mathematica::m matb = Table(Mod(i + j, 3), List(i, 1, 2), List(j, 1, 2)];mathematica::m matc = Dot(mata, matb);mathematica::m matd = Det(matc);// Execute mathematica constructs and fetch the responseshell &lt;&lt; matd;shell &gt;&gt; determinant;// determinant can be converted to C++ machine sized typesstd::cout &lt;&lt; determinant &lt;&lt; std::endl; // Prints -2 The Mathematica functions declared with MATHEMATICA_DECLARE outside any function (may be inside a header) e.g. MATHEMATICA_DECLARE(Table), MATHEMATICA_DECLARE(Det) A symbols created using mathematica::symbol e.g. mathematica::symbol i(&quot;i&quot;), mathematica::symbol j(&quot;j&quot;) mathematica::m creates a mathematica construct mathematica::value holds the value returnd from mathematica 12345678910111213141516171819202122232425262728// Declare Mathematica functions MATHEMATICA_DECLARE(Table)MATHEMATICA_DECLARE(Mod)MATHEMATICA_DECLARE(Dot)MATHEMATICA_DECLARE(Det)// connect to mathematica (optionally pass argc, argv) See http://reference.wolfram.com/language/ref/c/WSOpenArgcArgv.htmlconnector shell;// Declare symbolsmathematica::symbol i(&quot;i&quot;);mathematica::symbol j(&quot;j&quot;);// declare variable to contain mathematica outputmathematica::value determinant;// create mathematica constructsmathematica::m mata = Table(Mod(i + j, 2), List(i, 1, 2), List(j, 1, 2));mathematica::m matb = Table(Mod(i + j, 3), List(i, 1, 2), List(j, 1, 2)];mathematica::m matc = Dot(mata, matb);mathematica::m matd = Det(matc);// Execute mathematica constructs and fetch the responseshell &lt;&lt; matd;shell &gt;&gt; determinant;// determinant can be converted to C++ machine sized typesstd::cout &lt;&lt; determinant &lt;&lt; std::endl; // Prints -2 Simple Example of adding all numbers in a list123456using namespace mathematica;symbol i(&quot;i&quot;); // declare mathematica symbol ivalue result_sum; // declare the variable to hold the resultshell &lt;&lt; Total(Table(i, List(i, 1, 10))); // In Mathematica Total[Table[i, {i, 1, 10}]]shell &gt;&gt; result_sum; result_sum is the result object that can be converted to int, double, std::string and streamed to std::ostream. 1234567std::cout &lt;&lt; result_sum &lt;&lt; std::endl; // Prints 55std::cout &lt;&lt; result_sum-&gt;stringify() &lt;&lt; std::endl; // Prints 55int sum1 = *result_sum; // auto coercion through type operator overloading for scaler typesint sum2 = cast&lt;int&gt;(result_sum);double sum3 = *result_sum;double sum4 = cast&lt;double&gt;(result_sum); std::cout &lt;&lt; sum1 &lt;&lt; &quot; &quot; &lt;&lt; sum2 &lt;&lt; &quot; &quot; &lt;&lt; sum3 &lt;&lt; &quot; &quot; &lt;&lt; sum4 &lt;&lt; std::endl; // Prints 55 55 55 55 Fetching composite results (in STL containers)mathematica::value can hold composite values returned from mathematica like this example of List 1234567symbol i(&quot;i&quot;); // declare mathematica symbol ivalue result_list; // declare the variable to hold the resultshell &lt;&lt; Table(i, List(i, 1, 10)); // In Mathematica Table[i, {i, 1, 10}]shell &gt;&gt; result_list;std::cout &lt;&lt; result_list &lt;&lt; std::endl; // Prints List[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]std::cout &lt;&lt; result_list-&gt;stringify() &lt;&lt; std::endl; // Prints List[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] mathematica::value object can be converted to an equivalent STL container like std::vector using mathematica::cast 12std::vector&lt;int&gt; list;list = cast&lt;std::vector&lt;int&gt;&gt;(result_list); Executing intermediate returned outputAn mathematica::value object can be using to build a mathematica::m construct. Here res_mata and res_matb are values returned by mathematica that we are passing inside Det. 12345678910111213value res_mata;value res_matb;value res_matc;value res_det;shell &lt;&lt; Table(Mod(i+j, 2), List(i, 1, 2), List(j, 1, 2));shell &gt;&gt; res_mata;shell &lt;&lt; Table(Mod(i+j, 3), List(i, 1, 2), List(j, 1, 2));shell &gt;&gt; res_matb;shell &lt;&lt; Dot(res_mata, res_matb);shell &gt;&gt; res_matc;shell &lt;&lt; Det(res_matc);shell &gt;&gt; res_det; Serialize struct to Mathematica Association12345678910111213struct point{ std::pair&lt;int, int&gt; location; std::string name; double elevation; point(): location(std::make_pair(0, 0)), name(&quot;&quot;), elevation (0.0f){} point (std::pair&lt;int, int&gt; loc, const std::string&amp; name_, double elevation_): location(loc), name(name_), elevation(elevation_){}};value result;point pti(std::make_pair(1, 1), &quot;Hallo&quot;, 100.0f);shell &lt;&lt; Evaluate(pti);shell &gt;&gt; result;point pto = cast&lt;point&gt;(result); The object pti of type struct point is the above example will be serialized as Association[Rule[&quot;location&quot;, List[1, 1]], Rule[&quot;name&quot;, &quot;Hallo&quot;], Rule[&quot;elevation&quot;, 100]]. The associations need to be declared as following. 12345MATHEMATICA_ASSOCIATE(point, std::pair&lt;int, int&gt;, std::string, double){ MATHEMATICA_PROPERTY(0, location) MATHEMATICA_PROPERTY(1, name) MATHEMATICA_PROPERTY(2, elevation)}; Mathematica++ Repo on GitLab","link":"/2018/09/23/mathematica/"},{"title":"Rumal (রুমাল) is a header only XML&#x2F;HTML&#x2F;SVG&#x2F;CSS&#x2F;Javascript Generator C++ library","text":"Rumal is a C++ library that can generate HTML/CSS/Javascript code from significantly identical C++ syntax.Currently it uses std::string which is supposed to be replaced with compile time strings. Injecting placeholders, is also planned but not yet implemented.This will make it usable as a template engine. 12345std::cout &lt;&lt; div(_id(42) / _class(&quot;test&quot;), span(_id(43) / _class(&quot;test&quot;), &quot;Hello&quot;), span(&quot;World&quot;) ); The above code prints 1234&lt;div id=&quot;42&quot; class=&quot;test&quot;&gt; &lt;span id=&quot;43&quot; class=&quot;test&quot;&gt; Hello &lt;/span&gt; World&lt;/div&gt; Rumal can be used to generate CSS too. 1234567891011select(&quot;.main&quot;, display(&quot;block&quot;) / position(&quot;relative&quot;), select(&quot;.heading&quot;, display(&quot;block&quot;) / position(&quot;relative&quot;) )) / select(&quot;.container&quot;, display(&quot;block&quot;) / position(&quot;relative&quot;)); With the above C++ code the following CSS is generated 1234567891011121314.container{ position: relative; display: block;}.main{ position: relative; display: block;}.main &gt; .heading{ position: relative; display: block;} Rumal can also be used as a kind of Quine (self replicating program) that generates Javascript from a significantly similar C++ syntax. However the Javascript generation part is incomplete and buggy. I am not getting enough time to complete / fix it. Use at your own risk 12345678assignable&lt;Node&gt; document(&quot;document&quot;);assignable&lt;Node&gt; y(&quot;y&quot;);auto script = jQuery(document).ready(function()[ jQuery(&quot;.hallo&quot;).click(function()[ jQuery(y).hide(), jQuery(&quot;.hello&quot;).hide() ]) ]); The above generates a similar javascript code. 123456jQuery(document).ready(function()[ jQuery(&quot;.hallo&quot;).click(function(){ jQuery(y).hide(), jQuery(&quot;.hello&quot;).hide() })}); In order to use rumal js first the OO skeleton of the Javascript types has to be specified 123456789101112131415161718192021using namespace rumal::js;struct fn_: callable_&lt;fn_&gt;{ fn_(): callable_&lt;fn_&gt;(&quot;fn&quot;){}};struct m1_: callable_&lt;m1_&gt;{ m1_(): callable_&lt;m1_&gt;(&quot;m1&quot;){}};struct m2_: callable_&lt;m2_&gt;{ m2_(): callable_&lt;m2_&gt;(&quot;m2&quot;){}};struct m4_: callable_&lt;m4_&gt;{ m4_(): callable_&lt;m4_&gt;(&quot;m4&quot;){}};struct m5_: callable_&lt;m5_&gt;{ m5_(): callable_&lt;m5_&gt;(&quot;m5&quot;){}}; Five void returning javascript functions fn, m1, m2, m4, m5 are specified. 1234567891011121314151617181920212223242526272829303132333435363738template &lt;typename T&gt;struct object4_{ method_&lt;m5_, T&gt; m5; object4_(const T&amp; pkt): m5(pkt){}};template &lt;typename T&gt;struct object3_{ method_&lt;m5_, T&gt; m5; property_&lt;object4_, T&gt; o4; object3_(const T&amp; pkt): m5(pkt), o4(&quot;o4&quot;, pkt){}};template &lt;typename T&gt;struct object2_: iterable_&lt;T, object3_&gt;{ method_&lt;m4_, T&gt; m4; object2_(const T&amp; pkt): iterable_&lt;T, object3_&gt;(pkt), m4(pkt){}};struct m3_: callable_&lt;m3_, object2_&gt;{ m3_(): callable_&lt;m3_, object2_&gt;(&quot;m3&quot;){}};template &lt;typename T&gt;struct object1_{ rumal::js::method_&lt;m1_, T&gt; m1; rumal::js::method_&lt;m2_, T&gt; m2; rumal::js::method_&lt;m3_, T&gt; m3; object1_(const T&amp; pkt): m1(pkt), m2(pkt), m3(pkt){}};struct m0_: rumal::js::callable_&lt;m0_, object1_&gt;{ m0_(): rumal::js::callable_&lt;m0_, object1_&gt;(&quot;m0&quot;){}}; Javascript Classes object4, object3, object2, and object1 are specified. The object4 has a method m5 in it. So any function returning object4 will have a .m5() method callable. Similarly object3 describes the method m5 and a property o4 or type object4. So any function f returning an instance of object4 will have .m5() as well as .o4.m5() accessible. Finally the object1 Class have three methods m1, m2 and m3. Following are somw example usages. 1234567891011121314151617fn_ fn;m0_ m0;std::cout &lt;&lt; fn(1, 2.5) &lt;&lt; std::endl;std::cout &lt;&lt; m0(1, 4.5) &lt;&lt; std::endl;std::cout &lt;&lt; m0(1, 4.5).m1(4, 2.7) &lt;&lt; std::endl;std::cout &lt;&lt; m0(1, 4.5).m3(4, 2.7) &lt;&lt; std::endl;std::cout &lt;&lt; m0(1, 4.5).m3(4, 2.7).m4 &lt;&lt; std::endl;std::cout &lt;&lt; m0(1, 4.5).m3(4, 2.7).m4(4, 75.5) &lt;&lt; std::endl;std::cout &lt;&lt; m0(1, 4.5).m3(4, 2.7, &quot;hello&quot;)[1].m5 &lt;&lt; std::endl;std::cout &lt;&lt; m0(1, 4.5).m3(4, 2.7, &quot;hi&quot;)[1].m5(&quot;Hallo&quot;) &lt;&lt; std::endl;std::cout &lt;&lt; m0(1, 4.5).m3(4, 2.7, &quot;hi&quot;)[1].o4 &lt;&lt; std::endl;std::cout &lt;&lt; m0(1, 4.5).m3(4, 2.7, &quot;hi&quot;)[1].o4.m5 &lt;&lt; std::endl;std::cout &lt;&lt; m0(1, 4.5).m3(4, 2.7, &quot;hi&quot;)[1].o4.m5(42) &lt;&lt; std::endl;std::cout &lt;&lt; m0(1, 4.5).m3(4, 2.7, &quot;hi&quot;)[1].o4.m5() &lt;&lt; std::endl;std::cout &lt;&lt; m0(1, 4.5).m3(4, 2.7, &quot;hi&quot;)[1].o4.m5(42) - m0(1, 4.5).m3(4, 2.7, &quot;hi&quot;)[1].o4 + fn * m0 &lt;&lt; std::endl;std::cout &lt;&lt; (m0(1, 4.5) , m0(1, 4.5).m1(4, 2.7) , m0(1, 4.5).m3(4, 2.7, &quot;hi&quot;)[1].o4) &lt;&lt; std::endl; The above code generates the following javascript, which is much like printing itself. 1234567891011121314fn(1, 2.5)m0(1, 4.5)m0(1, 4.5).m1(4, 2.7)m0(1, 4.5).m3(4, 2.7)m0(1, 4.5).m3(4, 2.7).m4m0(1, 4.5).m3(4, 2.7).m4(4, 75.5)m0(1, 4.5).m3(4, 2.7, &quot;hello&quot;)[1].m5m0(1, 4.5).m3(4, 2.7, &quot;hi&quot;)[1].m5(&quot;Hallo&quot;)m0(1, 4.5).m3(4, 2.7, &quot;hi&quot;)[1].o4m0(1, 4.5).m3(4, 2.7, &quot;hi&quot;)[1].o4.m5m0(1, 4.5).m3(4, 2.7, &quot;hi&quot;)[1].o4.m5(42)m0(1, 4.5).m3(4, 2.7, &quot;hi&quot;)[1].o4.m5()m0(1, 4.5).m3(4, 2.7, &quot;hi&quot;)[1].o4.m5(42) - m0(1, 4.5).m3(4, 2.7, &quot;hi&quot;)[1].o4 + fn * m0(m0(1, 4.5) , m0(1, 4.5).m1(4, 2.7) , m0(1, 4.5).m3(4, 2.7, &quot;hi&quot;)[1].o4) In the example below a javascript variable (assignable) x is created. The functions _const and _let generates the const and let javascript keywords. &lt;&lt;==is used as assignment operator instead. 1234auto x = rumal::js::assignable&lt;object2_&gt;(&quot;x&quot;);std::cout &lt;&lt; x &lt;&lt; std::endl;std::cout &lt;&lt; _const(x) &lt;&lt; std::endl;std::cout &lt;&lt; (_let(x) &lt;&lt;= m0(1, 4.5)) &lt;&lt; std::endl; The above C++ code generates the following Javascript 123xconst xlet x = m0(1, 4.5) Next is the example of generating the conditional structure in Javascript [] in C++ generates {} in Javascript 123456789101112131415161718std::cout &lt;&lt; ( 24 + m0(1, 4.5).m3(4, 2.7).m4 + 42 + &quot;Hallo World&quot;, _if(x &gt;= 1 &amp;&amp; 2*x &gt;= 1)[ m0(1, 4.5), m0(1, 4.5).m1(4, 2.7), m0(1, 4.5).m3(4, 2.7, &quot;hi&quot;)[1].o4 ], _else(x &lt; 0.5)[ m0(1, 4.5), m0(1, 4.5).m1(4, 2.7), m0(1, 4.5).m3(4, 2.7, &quot;hi&quot;)[1].o4 ], _else()[ m0(1, 4.5), m0(1, 4.5).m1(4, 2.7), m0(1, 4.5).m3(4, 2.7, &quot;hi&quot;)[1].o4 ] ) &lt;&lt; std::endl; Gitlab","link":"/2019/12/26/rumal/"},{"title":"Tash (ট্যাঁশ) an Open Source C++ library for ArangoDB and AQL","text":"I am working on Tash which is an Open Source C++ library for ArangoDB Database which includes APIs for HTTP based document access and a query builder for AQL (Arango Query Language). These are a few example usages. 12345678std::string name = &quot;Hijibijbij&quot;;tash::shell shell(&quot;school&quot;); shell &lt;&lt; select(&quot;s&quot;).in(&quot;students&quot;) / filter((clause(&quot;s.name&quot;) == name) &amp;&amp; (clause(&quot;s.fathers_name&quot;) == name)) / sort().asc(&quot;s._key&quot;) / yield(&quot;s&quot;); nlohmann::json result;shell &gt;&gt; result; The above generates an equivalent AQL and execute it over the arangodb connection 1234FOR s IN students FILTER s.name == &quot;Hijibijbij&quot; AND s.fathers_name == &quot;Hijibijbij&quot; SORT s._key ASC RETURN s Along with AQL generation it also performs normal HTTP API based document access. 1234567891011tash::vertex students(school, &quot;students&quot;);if(students.exists() == boost::beast::http::status::not_found){ students.create();}nlohmann::json document = { {&quot;name&quot;, &quot;Hijibijbij&quot;}, {&quot;fathers_name&quot;, &quot;Hijibijbij&quot;}, {&quot;uncles_name&quot;, &quot;Hijibijbij&quot;}};boost::beast::http::status status = students.add(document);nlohmann::json hijibijbij = students.by_key(document[&quot;_key&quot;].get&lt;std::string&gt;()); Unlike Fuerte it does not require velocypack or node. Instead it uses nlohmann::json and Boost.Beast libraries Buildingprerequisites C++ compiler CMake boost library nlohmann::json [OPTIONAL] (tash ships with a single file version of nlohmann::json) compiling12345git clone https://gitlab.com/neel.basu/tash.gitmkdir buildcd buildcmake ..make Basic Example12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;tash/arango.h&gt;#include &lt;boost/format.hpp&gt;#include &lt;boost/beast/http/status.hpp&gt;int main(){ tash::shell school(&quot;school&quot;); // shell(&quot;school&quot;, &quot;localhost&quot;, 8529, &quot;root&quot;, &quot;root&quot;) if(school.exists() == boost::beast::http::status::not_found){ school.create(); } tash::vertex students(school, &quot;students&quot;); if(students.exists() == boost::beast::http::status::not_found){ students.create(); } nlohmann::json document = { {&quot;name&quot;, &quot;Hijibijbij&quot;}, {&quot;fathers_name&quot;, &quot;Hijibijbij&quot;}, {&quot;uncles_name&quot;, &quot;Hijibijbij&quot;} }; boost::beast::http::status status = students.add(document); if(status == boost::beast::http::status::accepted){ std::cout &lt;&lt; boost::format(&quot;document created with key %1%&quot;) % document[&quot;_key&quot;] &lt;&lt; std::endl; }else{ std::cout &lt;&lt; &quot;Failed to create document with error &quot; &lt;&lt; status &lt;&lt; std::endl; } nlohmann::json hijibijbij = students.by_key(document[&quot;_key&quot;].get&lt;std::string&gt;()); std::cout &lt;&lt; &quot;retrieved document &quot; &lt;&lt; std::endl; std::cout &lt;&lt; hijibijbij &lt;&lt; std::endl; return 0;} AQL (Arango Query Language) BuilderRetrieve / Filter / Sort1234567tash::shell shell(&quot;school&quot;); // shell(&quot;school&quot;, &quot;localhost&quot;, 8529, &quot;root&quot;, &quot;root&quot;)shell &lt;&lt; select(&quot;s&quot;).in(&quot;students&quot;) // use select instead of FOR because for is a C++ keyword / filter((clause(&quot;s.name&quot;) == name) &amp;&amp; (clause(&quot;s.fathers_name&quot;) == name)) // using std::string puts quotes around the value / sort().asc(&quot;s._key&quot;) / yield(&quot;s&quot;); // use yield instead of RETURN because return is a C++ keywordnlohmann::json result;shell &gt;&gt; result; 1234FOR s IN students FILTER s.name == &quot;Hijibijbij&quot; AND s.fathers_name == &quot;Hijibijbij&quot; SORT s._key ASC RETURN s 1234 select(&quot;s&quot;).in(&quot;students&quot;) / filter((clause(&quot;s.name&quot;) == &quot;s.fathers_name&quot;)) // using C string doesn't put quotes around the value/ sort().asc(&quot;s._key&quot;)/ yield(&quot;s&quot;); 1234FOR s IN students FILTER s.name == s.fathers_name SORT s._key ASC RETURN s insertinsert single row1234insert(nlohmann::json{ {&quot;name&quot;, &quot;tash&quot;}, {&quot;fathers_name&quot;, &quot;tash&quot;}}).in(&quot;students&quot;); 1INSERT {&quot;fathers_name&quot;:&quot;tash&quot;,&quot;name&quot;:&quot;tash&quot;} INTO students insert multiple rows1234select(&quot;u&quot;).in({ {&quot;name&quot;, &quot;tash&quot;}, {&quot;fathers_name&quot;, &quot;tash&quot;}}) / insert(&quot;u&quot;).in(&quot;students&quot;) 12FOR u IN {&quot;fathers_name&quot;:&quot;tash&quot;,&quot;name&quot;:&quot;tash&quot;} INSERT u INTO students generate rows in nlohmann::json string values are always quoted tash::assign generates non-nested key value pairs (non-nested json) C style strings are unquoted, std::string is quoted 123456 select(&quot;i&quot;).in(1, 10) / insert( assign(&quot;name&quot;, &quot;CONCAT('tash', i)&quot;) .assign(&quot;gender&quot;, &quot;(i % 2 == 0 ? 'f' : 'm')&quot;) .assign(&quot;fathers_name&quot;, std::string(&quot;tash&quot;)) ).in(&quot;users&quot;) 123456FOR i IN 1..10 INSERT { name: CONCAT('test', i), gender: (i % 2 == 0 ? 'f' : 'm'), fathers_name: &quot;tash&quot; } INTO users update12345update(nlohmann::json{ {&quot;_key&quot;, 1234}}).with({ {&quot;uncles_name&quot;, &quot;tash&quot;}}).in(&quot;students&quot;) 1UPDATE {&quot;_key&quot;:1234} WITH {&quot;uncles_name&quot;:&quot;tash&quot;} IN students let123456789101112131415 (let(&quot;date&quot;) = &quot;DATE_NOW()&quot;)/ select(&quot;user&quot;).in(&quot;users&quot;)/ filter(clause(&quot;user.isImportantUser&quot;) == &quot;null&quot;)/ (let(&quot;numberOfLogins&quot;) = select(&quot;login&quot;).in(&quot;logins&quot;) / filter(clause(&quot;login.user&quot;) == &quot;user._key&quot;) / collect().with(&quot;COUNT&quot;).in(&quot;numLogins&quot;) / yield(&quot;numLogins&quot;))/ filter(clause(&quot;numberOfLogins&quot;) &gt; 50)/ update(&quot;user&quot;).with( assign(&quot;isImportantUser&quot;, 1) .assign(&quot;dateBecameImportant&quot;, &quot;date&quot;) .assign(&quot;uncles_name&quot;, std::string(&quot;tash&quot;))).in(&quot;users&quot;) 123456789101112131415LET date = DATE_NOW() FOR user IN users FILTER user.isImportantUser == null LET numberOfLogins = ( FOR login IN logins FILTER login.user == user._key COLLECT WITH COUNT INTO numLogins RETURN numLogins ) FILTER numberOfLogins &gt; 50 UPDATE user WITH { isImportantUser: 1, dateBecameImportant: date, uncles_name: &quot;tash&quot; } IN users replace123456replace(nlohmann::json{ {&quot;_key&quot;, 1234}}).with({ {&quot;name&quot;, &quot;tash&quot;}, {&quot;uncles_name&quot;, &quot;tash&quot;}}).in(&quot;students&quot;) 12345REPLACE {&quot;_key&quot;:1234} WITH { &quot;name&quot;:&quot;tash&quot;, &quot;uncles_name&quot;:&quot;tash&quot; } IN students remove1erase(assign(&quot;_key&quot;, &quot;1&quot;)).in(&quot;students&quot;) 1REMOVE {_key: 1} IN students upsert123456789upsert(nlohmann::json{ {&quot;name&quot;, &quot;tokai&quot;}}).insert({ {&quot;name&quot;, &quot;tokai&quot;}, {&quot;fathers_name&quot;, &quot;tokai&quot;}}).update({ {&quot;name&quot;, &quot;tokai&quot;}, {&quot;fathers_name&quot;, &quot;tokai&quot;}}).in(&quot;students&quot;) 1234UPSERT {&quot;name&quot;:&quot;tokai&quot;} INSERT {&quot;fathers_name&quot;:&quot;tokai&quot;,&quot;name&quot;:&quot;tokai&quot;} UPDATE {&quot;fathers_name&quot;:&quot;tokai&quot;,&quot;name&quot;:&quot;tokai&quot;} IN students create graph12345auto graph = ddl::graph_definition(&quot;corpus&quot;) .add_edge_definition(ddl::edge_definition(&quot;StructuralE&quot;).add_from(&quot;Word&quot;).add_to(&quot;Word&quot;).add_to(&quot;Sentence&quot;)) .add_edge_definition(ddl::edge_definition(&quot;WNeighbourhoodE&quot;).add_from(&quot;Word&quot;).add_to(&quot;Word&quot;)) .add_edge_definition(ddl::edge_definition(&quot;InstanceE&quot;).add_from(&quot;Word&quot;).add_to(&quot;Vocabulary&quot;));query(&quot;_api/gharial&quot;, graph.json().dump()); create aql function1234567891011std::string function_str = R&quot;( function(p1, p2){ // function body })&quot;;auto fnc = nlohmann::json({ {&quot;name&quot;, &quot;NS::FNAME&quot;}, {&quot;code&quot;, function_str}, {&quot;isDeterministic&quot;, true}});query(&quot;_api/aqlfunction&quot;, fnc.dump());","link":"/2019/09/19/tash/"}],"tags":[{"name":"Latex","slug":"Latex","link":"/tags/Latex/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Utilities","slug":"Utilities","link":"/tags/Utilities/"},{"name":"Mathematica","slug":"Mathematica","link":"/tags/Mathematica/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"XML","slug":"XML","link":"/tags/XML/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"ArangoDB","slug":"ArangoDB","link":"/tags/ArangoDB/"},{"name":"Graph Database","slug":"Graph-Database","link":"/tags/Graph-Database/"}],"categories":[{"name":"Programming","slug":"Programming","link":"/categories/Programming/"},{"name":"Announcement","slug":"Announcement","link":"/categories/Announcement/"}]}