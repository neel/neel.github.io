{"pages":[{"title":"Publications","text":"A Framework for Delivering IoT Services with Virtual Sensors: Case Study Remote Healthcare DeliveryNandini Mukherjee, Sunanda Bose, Himadri Sekhar RayInteroperability in IoT for Smart SystemsCRC Press 2020 Around the world in 60 days: an exploratory study of impact of COVID-19 on online global news sentimentAmartya Chakraborty, Sunanda BoseJournal of Computational Social ScienceSpringer 2020 SenSchedule: Scheduling Heterogeneous Periodic Sensing Resources with Non Uniform Performance in IoTSunanda Bose, Nandini MukherjeeIEEE Transactions on Services ComputingIEEE 2020 A Framework for Heterogeneous Resource Allocation in Sensor-Cloud EnvironmentSunanda Bose, Debangana Sarkar, Nandini MukherjeeWireless Personal Communications vol. 108 no. 1Springer US 2019 LEPaNTU: Long Polling Based Energy Efficient Passive NAT Traversal through UDPSunanda Bose, Akash Chowdhury, Nandini Mukherjee2019 7th International Conference on Future Internet of Things and Cloud (FiCloud)IEEE 2019 A Load Balancing Approach to Resource Provisioning in Cloud Infrastructure with a Grouping Genetic AlgorithmKaustabha Ray, Sunanda Bose, Nandini Mukherjee2018 International Conference on Current Trends towards Converging Technologies (ICCTCT)IEEE 2018 Impact of Mobility on Community Sensing with Environment SensorsAtanu Mandal, Sunanda Bose, Nandini Mukherjee2017 13th International Conference on Signal-Image Technology &amp; Internet-Based Systems (SITIS)IEEE 2017 PrIOR: A prime number based I/O redirection algorithm for sensor-cloud infrastructureSunanda Bose, Nandini Mukherjee2016 International Conference on High Performance Computing &amp; Simulation (HPCS)IEEE 2016 Virtual Sensors in Remote Healthcare Delivery: Some Case Studies.Nandini Mukherjee, Suman Sankar Bhunia, Sunanda BoseProceedings of the 9th International Joint Conference on Biomedical Engineering Systems and Technologies - Volume 5HEALTHINF 2016 Sensiaas: A sensor-cloud infrastructure with sensor virtualizationSunanda Bose, Nandini Mukherjee2016 IEEE 3rd International Conference on Cyber Security and Cloud Computing (CSCloud)IEEE 2016 Environment monitoring in smart cities using virtual sensorsSunanda Bose, Nandini Mukherjee, Sujoy Mistry2016 IEEE 4th International Conference on Future Internet of Things and Cloud (FiCloud)IEEE 2016 Towards a sensor-cloud infrastructure with sensor virtualizationSunanda Bose, Atrayee Gupta, Sriyanjana Adhikary, Nandini MukherjeeProceedings of the Second Workshop on Mobile Sensing, Computing and CommunicationACM 2015 Collation: Prabhed and Its PredecessorsSukanta Chaudhuri, Spandana Bhowmik, Sunanda BoseBichitra: The Making of an Online Tagore VariorumSpringer 2015","link":"/publications/index.html"}],"posts":[{"title":"Mathematica++ a C++ library that speaks Mathematica","text":"12345678symbol x(&quot;x&quot;);value res;std::string method = &quot;Newton&quot;;shell &lt;&lt; Values(FindRoot(ArcTan(1000 * Cos(x)), List(x, 1, 2), Rule(&quot;Method&quot;) = method));shell &gt;&gt; res;std::vector&lt;double&gt; results = cast&lt;std::vector&lt;double&gt;&gt;(res);std::cout &lt;&lt; results[0] &lt;&lt; std::endl; // Prints 10.9956 A C++ Library that talks MathematicaDot product and Determinant calculation in Mathematica Language 12345mata = Table[Mod[i + j, 2], {i, 1, 2}, {j, 1, 2}];matb = Table[Mod[i + j, 3], {i, 1, 2}, {j, 1, 2}];matc = Dot[mata, matb];matd = Det[matc]; Equivalent C++ code with Mathematica++ 1234567891011mathematica::m mata = Table(Mod(i + j, 2), List(i, 1, 2), List(j, 1, 2));mathematica::m matb = Table(Mod(i + j, 3), List(i, 1, 2), List(j, 1, 2)];mathematica::m matc = Dot(mata, matb);mathematica::m matd = Det(matc);// Execute mathematica constructs and fetch the responseshell &lt;&lt; matd;shell &gt;&gt; determinant;// determinant can be converted to C++ machine sized typesstd::cout &lt;&lt; determinant &lt;&lt; std::endl; // Prints -2 The Mathematica functions declared with MATHEMATICA_DECLARE outside any function (may be inside a header) e.g. MATHEMATICA_DECLARE(Table), MATHEMATICA_DECLARE(Det) A symbols created using mathematica::symbol e.g. mathematica::symbol i(&quot;i&quot;), mathematica::symbol j(&quot;j&quot;) mathematica::m creates a mathematica construct mathematica::value holds the value returnd from mathematica 12345678910111213141516171819202122232425262728// Declare Mathematica functions MATHEMATICA_DECLARE(Table)MATHEMATICA_DECLARE(Mod)MATHEMATICA_DECLARE(Dot)MATHEMATICA_DECLARE(Det)// connect to mathematica (optionally pass argc, argv) See http://reference.wolfram.com/language/ref/c/WSOpenArgcArgv.htmlconnector shell;// Declare symbolsmathematica::symbol i(&quot;i&quot;);mathematica::symbol j(&quot;j&quot;);// declare variable to contain mathematica outputmathematica::value determinant;// create mathematica constructsmathematica::m mata = Table(Mod(i + j, 2), List(i, 1, 2), List(j, 1, 2));mathematica::m matb = Table(Mod(i + j, 3), List(i, 1, 2), List(j, 1, 2)];mathematica::m matc = Dot(mata, matb);mathematica::m matd = Det(matc);// Execute mathematica constructs and fetch the responseshell &lt;&lt; matd;shell &gt;&gt; determinant;// determinant can be converted to C++ machine sized typesstd::cout &lt;&lt; determinant &lt;&lt; std::endl; // Prints -2 Simple Example of adding all numbers in a list123456using namespace mathematica;symbol i(&quot;i&quot;); // declare mathematica symbol ivalue result_sum; // declare the variable to hold the resultshell &lt;&lt; Total(Table(i, List(i, 1, 10))); // In Mathematica Total[Table[i, {i, 1, 10}]]shell &gt;&gt; result_sum; result_sum is the result object that can be converted to int, double, std::string and streamed to std::ostream. 1234567std::cout &lt;&lt; result_sum &lt;&lt; std::endl; // Prints 55std::cout &lt;&lt; result_sum-&gt;stringify() &lt;&lt; std::endl; // Prints 55int sum1 = *result_sum; // auto coercion through type operator overloading for scaler typesint sum2 = cast&lt;int&gt;(result_sum);double sum3 = *result_sum;double sum4 = cast&lt;double&gt;(result_sum); std::cout &lt;&lt; sum1 &lt;&lt; &quot; &quot; &lt;&lt; sum2 &lt;&lt; &quot; &quot; &lt;&lt; sum3 &lt;&lt; &quot; &quot; &lt;&lt; sum4 &lt;&lt; std::endl; // Prints 55 55 55 55 Fetching composite results (in STL containers)mathematica::value can hold composite values returned from mathematica like this example of List 1234567symbol i(&quot;i&quot;); // declare mathematica symbol ivalue result_list; // declare the variable to hold the resultshell &lt;&lt; Table(i, List(i, 1, 10)); // In Mathematica Table[i, {i, 1, 10}]shell &gt;&gt; result_list;std::cout &lt;&lt; result_list &lt;&lt; std::endl; // Prints List[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]std::cout &lt;&lt; result_list-&gt;stringify() &lt;&lt; std::endl; // Prints List[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] mathematica::value object can be converted to an equivalent STL container like std::vector using mathematica::cast 12std::vector&lt;int&gt; list;list = cast&lt;std::vector&lt;int&gt;&gt;(result_list); Executing intermediate returned outputAn mathematica::value object can be using to build a mathematica::m construct. Here res_mata and res_matb are values returned by mathematica that we are passing inside Det. 12345678910111213value res_mata;value res_matb;value res_matc;value res_det;shell &lt;&lt; Table(Mod(i+j, 2), List(i, 1, 2), List(j, 1, 2));shell &gt;&gt; res_mata;shell &lt;&lt; Table(Mod(i+j, 3), List(i, 1, 2), List(j, 1, 2));shell &gt;&gt; res_matb;shell &lt;&lt; Dot(res_mata, res_matb);shell &gt;&gt; res_matc;shell &lt;&lt; Det(res_matc);shell &gt;&gt; res_det; Serialize struct to Mathematica Association12345678910111213struct point{ std::pair&lt;int, int&gt; location; std::string name; double elevation; point(): location(std::make_pair(0, 0)), name(&quot;&quot;), elevation (0.0f){} point (std::pair&lt;int, int&gt; loc, const std::string&amp; name_, double elevation_): location(loc), name(name_), elevation(elevation_){}};value result;point pti(std::make_pair(1, 1), &quot;Hallo&quot;, 100.0f);shell &lt;&lt; Evaluate(pti);shell &gt;&gt; result;point pto = cast&lt;point&gt;(result); The object pti of type struct point is the above example will be serialized as Association[Rule[&quot;location&quot;, List[1, 1]], Rule[&quot;name&quot;, &quot;Hallo&quot;], Rule[&quot;elevation&quot;, 100]]. The associations need to be declared as following. 12345MATHEMATICA_ASSOCIATE(point, std::pair&lt;int, int&gt;, std::string, double){ MATHEMATICA_PROPERTY(0, location) MATHEMATICA_PROPERTY(1, name) MATHEMATICA_PROPERTY(2, elevation)}; Mathematica++ Repo on GitLab","link":"/2018/09/23/mathematica/"},{"title":"Tash an Open Source C++ library for ArangoDB and AQL","text":"I am working on Tash which is a small Open Source C++ library for ArangoDB Database which includes APIs for HTTP based document access and a query builder for AQL (Arango Query Language). These are a few example usages. 12345678std::string name = &quot;Hijibijbij&quot;;tash::shell shell(&quot;school&quot;); shell &lt;&lt; select(&quot;s&quot;).in(&quot;students&quot;) / filter((clause(&quot;s.name&quot;) == name) &amp;&amp; (clause(&quot;s.fathers_name&quot;) == name)) / sort().asc(&quot;s._key&quot;) / yield(&quot;s&quot;); nlohmann::json result;shell &gt;&gt; result; The above generates an equivalent AQL and execute it over the arangodb connection 1234FOR s IN students FILTER s.name == &quot;Hijibijbij&quot; AND s.fathers_name == &quot;Hijibijbij&quot; SORT s._key ASC RETURN s Along with AQL generation it also performs normal HTTP API based document access. 1234567891011tash::vertex students(school, &quot;students&quot;);if(students.exists() == boost::beast::http::status::not_found){ students.create();}nlohmann::json document = { {&quot;name&quot;, &quot;Hijibijbij&quot;}, {&quot;fathers_name&quot;, &quot;Hijibijbij&quot;}, {&quot;uncles_name&quot;, &quot;Hijibijbij&quot;}};boost::beast::http::status status = students.add(document);nlohmann::json hijibijbij = students.by_key(document[&quot;_key&quot;].get&lt;std::string&gt;()); Unlike Fuerte it does not require velocypack or node. Instead it uses nlohmann::json and Boost.Beast libraries Buildingprerequisites C++ compiler CMake boost library nlohmann::json [OPTIONAL] (tash ships with a single file version of nlohmann::json) compiling12345git clone https://gitlab.com/neel.basu/tash.gitmkdir buildcd buildcmake ..make Basic Example12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;tash/arango.h&gt;#include &lt;boost/format.hpp&gt;#include &lt;boost/beast/http/status.hpp&gt;int main(){ tash::shell school(&quot;school&quot;); // shell(&quot;school&quot;, &quot;localhost&quot;, 8529, &quot;root&quot;, &quot;root&quot;) if(school.exists() == boost::beast::http::status::not_found){ school.create(); } tash::vertex students(school, &quot;students&quot;); if(students.exists() == boost::beast::http::status::not_found){ students.create(); } nlohmann::json document = { {&quot;name&quot;, &quot;Hijibijbij&quot;}, {&quot;fathers_name&quot;, &quot;Hijibijbij&quot;}, {&quot;uncles_name&quot;, &quot;Hijibijbij&quot;} }; boost::beast::http::status status = students.add(document); if(status == boost::beast::http::status::accepted){ std::cout &lt;&lt; boost::format(&quot;document created with key %1%&quot;) % document[&quot;_key&quot;] &lt;&lt; std::endl; }else{ std::cout &lt;&lt; &quot;Failed to create document with error &quot; &lt;&lt; status &lt;&lt; std::endl; } nlohmann::json hijibijbij = students.by_key(document[&quot;_key&quot;].get&lt;std::string&gt;()); std::cout &lt;&lt; &quot;retrieved document &quot; &lt;&lt; std::endl; std::cout &lt;&lt; hijibijbij &lt;&lt; std::endl; return 0;} AQL (Arango Query Language) BuilderRetrieve / Filter / Sort1234567tash::shell shell(&quot;school&quot;); // shell(&quot;school&quot;, &quot;localhost&quot;, 8529, &quot;root&quot;, &quot;root&quot;)shell &lt;&lt; select(&quot;s&quot;).in(&quot;students&quot;) // use select instead of FOR because for is a C++ keyword / filter((clause(&quot;s.name&quot;) == name) &amp;&amp; (clause(&quot;s.fathers_name&quot;) == name)) // using std::string puts quotes around the value / sort().asc(&quot;s._key&quot;) / yield(&quot;s&quot;); // use yield instead of RETURN because return is a C++ keywordnlohmann::json result;shell &gt;&gt; result; 1234FOR s IN students FILTER s.name == &quot;Hijibijbij&quot; AND s.fathers_name == &quot;Hijibijbij&quot; SORT s._key ASC RETURN s 1234 select(&quot;s&quot;).in(&quot;students&quot;) / filter((clause(&quot;s.name&quot;) == &quot;s.fathers_name&quot;)) // using C string doesn't put quotes around the value/ sort().asc(&quot;s._key&quot;)/ yield(&quot;s&quot;); 1234FOR s IN students FILTER s.name == s.fathers_name SORT s._key ASC RETURN s insertinsert single row1234insert(nlohmann::json{ {&quot;name&quot;, &quot;tash&quot;}, {&quot;fathers_name&quot;, &quot;tash&quot;}}).in(&quot;students&quot;); 1INSERT {&quot;fathers_name&quot;:&quot;tash&quot;,&quot;name&quot;:&quot;tash&quot;} INTO students insert multiple rows1234select(&quot;u&quot;).in({ {&quot;name&quot;, &quot;tash&quot;}, {&quot;fathers_name&quot;, &quot;tash&quot;}}) / insert(&quot;u&quot;).in(&quot;students&quot;) 12FOR u IN {&quot;fathers_name&quot;:&quot;tash&quot;,&quot;name&quot;:&quot;tash&quot;} INSERT u INTO students generate rows in nlohmann::json string values are always quoted tash::assign generates non-nested key value pairs (non-nested json) C style strings are unquoted, std::string is quoted 123456 select(&quot;i&quot;).in(1, 10) / insert( assign(&quot;name&quot;, &quot;CONCAT('tash', i)&quot;) .assign(&quot;gender&quot;, &quot;(i % 2 == 0 ? 'f' : 'm')&quot;) .assign(&quot;fathers_name&quot;, std::string(&quot;tash&quot;)) ).in(&quot;users&quot;) 123456FOR i IN 1..10 INSERT { name: CONCAT('test', i), gender: (i % 2 == 0 ? 'f' : 'm'), fathers_name: &quot;tash&quot; } INTO users update12345update(nlohmann::json{ {&quot;_key&quot;, 1234}}).with({ {&quot;uncles_name&quot;, &quot;tash&quot;}}).in(&quot;students&quot;) 1UPDATE {&quot;_key&quot;:1234} WITH {&quot;uncles_name&quot;:&quot;tash&quot;} IN students let123456789101112131415 (let(&quot;date&quot;) = &quot;DATE_NOW()&quot;)/ select(&quot;user&quot;).in(&quot;users&quot;)/ filter(clause(&quot;user.isImportantUser&quot;) == &quot;null&quot;)/ (let(&quot;numberOfLogins&quot;) = select(&quot;login&quot;).in(&quot;logins&quot;) / filter(clause(&quot;login.user&quot;) == &quot;user._key&quot;) / collect().with(&quot;COUNT&quot;).in(&quot;numLogins&quot;) / yield(&quot;numLogins&quot;))/ filter(clause(&quot;numberOfLogins&quot;) &gt; 50)/ update(&quot;user&quot;).with( assign(&quot;isImportantUser&quot;, 1) .assign(&quot;dateBecameImportant&quot;, &quot;date&quot;) .assign(&quot;uncles_name&quot;, std::string(&quot;tash&quot;))).in(&quot;users&quot;) 123456789101112131415LET date = DATE_NOW() FOR user IN users FILTER user.isImportantUser == null LET numberOfLogins = ( FOR login IN logins FILTER login.user == user._key COLLECT WITH COUNT INTO numLogins RETURN numLogins ) FILTER numberOfLogins &gt; 50 UPDATE user WITH { isImportantUser: 1, dateBecameImportant: date, uncles_name: &quot;tash&quot; } IN users replace123456replace(nlohmann::json{ {&quot;_key&quot;, 1234}}).with({ {&quot;name&quot;, &quot;tash&quot;}, {&quot;uncles_name&quot;, &quot;tash&quot;}}).in(&quot;students&quot;) 12345REPLACE {&quot;_key&quot;:1234} WITH { &quot;name&quot;:&quot;tash&quot;, &quot;uncles_name&quot;:&quot;tash&quot; } IN students remove1erase(assign(&quot;_key&quot;, &quot;1&quot;)).in(&quot;students&quot;) 1REMOVE {_key: 1} IN students upsert123456789upsert(nlohmann::json{ {&quot;name&quot;, &quot;tokai&quot;}}).insert({ {&quot;name&quot;, &quot;tokai&quot;}, {&quot;fathers_name&quot;, &quot;tokai&quot;}}).update({ {&quot;name&quot;, &quot;tokai&quot;}, {&quot;fathers_name&quot;, &quot;tokai&quot;}}).in(&quot;students&quot;) 1234UPSERT {&quot;name&quot;:&quot;tokai&quot;} INSERT {&quot;fathers_name&quot;:&quot;tokai&quot;,&quot;name&quot;:&quot;tokai&quot;} UPDATE {&quot;fathers_name&quot;:&quot;tokai&quot;,&quot;name&quot;:&quot;tokai&quot;} IN students create graph12345auto graph = ddl::graph_definition(&quot;corpus&quot;) .add_edge_definition(ddl::edge_definition(&quot;StructuralE&quot;).add_from(&quot;Word&quot;).add_to(&quot;Word&quot;).add_to(&quot;Sentence&quot;)) .add_edge_definition(ddl::edge_definition(&quot;WNeighbourhoodE&quot;).add_from(&quot;Word&quot;).add_to(&quot;Word&quot;)) .add_edge_definition(ddl::edge_definition(&quot;InstanceE&quot;).add_from(&quot;Word&quot;).add_to(&quot;Vocabulary&quot;));query(&quot;_api/gharial&quot;, graph.json().dump()); create aql function1234567891011std::string function_str = R&quot;( function(p1, p2){ // function body })&quot;;auto fnc = nlohmann::json({ {&quot;name&quot;, &quot;NS::FNAME&quot;}, {&quot;code&quot;, function_str}, {&quot;isDeterministic&quot;, true}});query(&quot;_api/aqlfunction&quot;, fnc.dump());","link":"/2019/09/19/tash/"}],"tags":[{"name":"Mathematica","slug":"Mathematica","link":"/tags/Mathematica/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"ArangoDB","slug":"ArangoDB","link":"/tags/ArangoDB/"},{"name":"Graph Database","slug":"Graph-Database","link":"/tags/Graph-Database/"}],"categories":[{"name":"Announcement","slug":"Announcement","link":"/categories/Announcement/"}]}